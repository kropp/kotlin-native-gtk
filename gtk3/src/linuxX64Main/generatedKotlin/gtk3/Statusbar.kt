package gtk3

import kotlin.String
import kotlin.UInt
import kotlin.Unit
import kotlinx.cinterop.ByteVar
import kotlinx.cinterop.CFunction
import kotlinx.cinterop.COpaquePointer
import kotlinx.cinterop.CPointed
import kotlinx.cinterop.CPointer
import kotlinx.cinterop.asStableRef
import kotlinx.cinterop.reinterpret
import kotlinx.cinterop.staticCFunction
import kotlinx.cinterop.toKString
import libgtk3.GtkBox
import libgtk3.GtkStatusbar
import libgtk3.GtkWidget
import libgtk3.gtk_statusbar_get_context_id
import libgtk3.gtk_statusbar_get_message_area
import libgtk3.gtk_statusbar_new
import libgtk3.gtk_statusbar_pop
import libgtk3.gtk_statusbar_push
import libgtk3.gtk_statusbar_remove
import libgtk3.gtk_statusbar_remove_all

inline fun Container.statusbar(init: Statusbar.() -> Unit = {}): Statusbar =
        Statusbar().apply { init(); this@statusbar.add(this) }

private fun Statusbar_onTextPopped_Handler(
    sender: CPointer<in CPointed>?,
    context_id: UInt,
    text: CPointer<ByteVar>,
    _data: COpaquePointer?
) {
    _data?.asStableRef<Statusbar>()?.get()?.onTextPopped?.emit(context_id, text.toKString())
}

private fun Statusbar_onTextPushed_Handler(
    sender: CPointer<in CPointed>?,
    context_id: UInt,
    text: CPointer<ByteVar>,
    _data: COpaquePointer?
) {
    _data?.asStableRef<Statusbar>()?.get()?.onTextPushed?.emit(context_id, text.toKString())
}

/**
 * A #GtkStatusbar is usually placed along the bottom of an application's
 * main #GtkWindow. It may provide a regular commentary of the application's
 * status (as is usually the case in a web browser, for example), or may be
 * used to simply output a message when the status changes, (when an upload
 * is complete in an FTP client, for example).
 *
 * Status bars in GTK+ maintain a stack of messages. The message at
 * the top of the each bar’s stack is the one that will currently be displayed.
 *
 * Any messages added to a statusbar’s stack must specify a
 * context id that is used to uniquely identify
 * the source of a message. This context id can be generated by
 * gtk_statusbar_get_context_id(), given a message and the statusbar that
 * it will be added to. Note that messages are stored in a stack, and when
 * choosing which message to display, the stack structure is adhered to,
 * regardless of the context identifier of a message.
 *
 * One could say that a statusbar maintains one stack of messages for
 * display purposes, but allows multiple message producers to maintain
 * sub-stacks of the messages they produced (via context ids).
 *
 * Status bars are created using gtk_statusbar_new().
 *
 * Messages are added to the bar’s stack with gtk_statusbar_push().
 *
 * The message at the top of the stack can be removed using
 * gtk_statusbar_pop(). A message can be removed from anywhere in the
 * stack if its message id was recorded at the time it was added. This
 * is done using gtk_statusbar_remove().
 *
 * # CSS node
 *
 * GtkStatusbar has a single CSS node with name statusbar.Retrieves the box containing the label
        widget.
 */
@GtkDsl
open class Statusbar internal constructor(override val widgetPtr: CPointer<GtkWidget>? = null) :
        Box() {
    private val self: CPointer<GtkStatusbar>?
        get() = widgetPtr!!.reinterpret()

    val statusbar: CPointer<GtkStatusbar>?
        get() = widgetPtr!!.reinterpret()

    val onTextPopped: Signal2<Statusbar, UInt, String, CFunction<(
        CPointer<in CPointed>?,
        UInt,
        CPointer<ByteVar>,
        COpaquePointer?
    ) -> Unit>> by lazy { Signal2<Statusbar, UInt, String, CFunction<(
                CPointer<in CPointed>?,
                UInt,
                CPointer<ByteVar>,
                COpaquePointer?
            ) -> Unit>>(widgetPtr!!, this, "text-popped",
                    staticCFunction(::Statusbar_onTextPopped_Handler)) }

    val onTextPushed: Signal2<Statusbar, UInt, String, CFunction<(
        CPointer<in CPointed>?,
        UInt,
        CPointer<ByteVar>,
        COpaquePointer?
    ) -> Unit>> by lazy { Signal2<Statusbar, UInt, String, CFunction<(
                CPointer<in CPointed>?,
                UInt,
                CPointer<ByteVar>,
                COpaquePointer?
            ) -> Unit>>(widgetPtr!!, this, "text-pushed",
                    staticCFunction(::Statusbar_onTextPushed_Handler)) }

    val messageArea: CPointer<GtkBox>
        get() = gtk_statusbar_get_message_area(self)!!.reinterpret()

    /**
     * Creates a new #GtkStatusbar ready for messages. */
    constructor() : this(gtk_statusbar_new()?.reinterpret())

    /**
     * Returns a new context identifier, given a description
     * of the actual context. Note that the description is
     * not shown in the UI.
     */
    fun getContextId(context_description: String): UInt = gtk_statusbar_get_context_id(self,
            context_description)

    /**
     * Removes the first message in the #GtkStatusbar’s stack
     * with the given context id.
     *
     * Note that this may not change the displayed message, if
     * the message at the top of the stack has a different
     * context id.
     */
    fun pop(context_id: UInt): Unit = gtk_statusbar_pop(self, context_id)

    /**
     * Pushes a new message onto a statusbar’s stack.
     */
    fun push(context_id: UInt, text: String): UInt = gtk_statusbar_push(self, context_id, text)

    /**
     * Forces the removal of a message from a statusbar’s stack.
     * The exact @context_id and @message_id must be specified.
     */
    fun remove(context_id: UInt, message_id: UInt): Unit = gtk_statusbar_remove(self, context_id,
            message_id)

    /**
     * Forces the removal of all messages from a statusbar's
     * stack with the exact @context_id.
     */
    fun removeAll(context_id: UInt): Unit = gtk_statusbar_remove_all(self, context_id)
}
